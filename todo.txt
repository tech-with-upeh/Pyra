emcc generated.cpp -o main.js -s WASM=1

 python -m http.server 8000  


 rename window to pages...


 #pragma once 
 #include <emscripten.h> 
 #include <string> #include <vector> #include <unordered_map> #include <sstream> #include <functional> #include <map> #include <algorithm> // -------------------- Callback System -------------------- inline std::map<int,std::function<void()>> g_callbacks; inline int g_callback_counter = 1; // Maps DOM id -> callback index inline std::map<std::string,int> g_domid_to_callback; extern "C" { void invokeCallback(int id) { if(g_callbacks.count(id)) g_callbacks[id](); } int getCallbackCount() { return g_callback_counter-1; } } // -------------------- VNode -------------------- struct VNode { std::string tag; std::string text; std::vector<VNode> children; std::unordered_map<std::string,std::string> attrs; std::function<void()> onclick; std::string dom_id; VNode() = default; // <- Default constructor added VNode(std::string t, std::string txt="") : tag(t), text(txt) {} }; // -------------------- VPage -------------------- struct VPage { std::string title; std::unordered_map<std::string,std::string> bodyAttrs; std::vector<VNode> children; }; // -------------------- Render VNode to HTML -------------------- inline std::string renderToHTML(VNode& node) { std::ostringstream oss; oss << "<" << node.tag; if(node.attrs.find("id") != node.attrs.end()) node.dom_id = node.attrs["id"]; else if(node.onclick) { node.dom_id = "vnode" + std::to_string(g_callback_counter); node.attrs["id"] = node.dom_id; } for(auto& [k,v] : node.attrs) oss << " " << k << "=\"" << v << "\""; if(node.onclick) { int cb_id = g_callback_counter++; g_callbacks[cb_id] = node.onclick; g_domid_to_callback[node.dom_id] = cb_id; } oss << ">"; if(!node.text.empty()) oss << node.text; for(auto& child : node.children) oss << renderToHTML(child); oss << "</" << node.tag << ">"; return oss.str(); } // -------------------- Wire JS onclicks -------------------- inline void wireOnClicks() { for(auto& [dom_id, cb_id] : g_domid_to_callback) { EM_ASM_({ let el = document.getElementById(UTF8ToString($0)); if(el) el.onclick = () => Module.ccall('invokeCallback','void',['number'],[$1]); }, dom_id.c_str(), cb_id); } } // -------------------- Patch -------------------- struct Patch { enum Type { TEXT, ATTR, ADD_CHILD, REMOVE_CHILD } type; std::string dom_id; std::string key; std::string value; VNode newNode; Patch(Type t, const std::string& id, const std::string& k = "", const std::string& v = "", const VNode& n = VNode("")) : type(t), dom_id(id), key(k), value(v), newNode(n) {} }; // -------------------- Diff Nodes -------------------- inline void diffNodes(const VNode& prev, const VNode& next, std::vector<Patch>& patches) { if(prev.text != next.text) patches.push_back(Patch(Patch::TEXT, next.dom_id, "", next.text)); for(auto& [k,v] : next.attrs) { if(prev.attrs.find(k) == prev.attrs.end() || prev.attrs.at(k) != v) patches.push_back(Patch(Patch::ATTR, next.dom_id, k, v)); } size_t common = std::min(prev.children.size(), next.children.size()); for(size_t i=0;i<common;i++) diffNodes(prev.children[i], next.children[i], patches); for(size_t i=common;i<next.children.size();i++) patches.push_back(Patch(Patch::ADD_CHILD, next.dom_id, "", "", next.children[i])); for(size_t i=common;i<prev.children.size();i++) patches.push_back(Patch(Patch::REMOVE_CHILD, prev.children[i].dom_id)); } // -------------------- Apply Patches -------------------- inline void applyPatches(const std::vector<Patch>& patches) { for(auto& p : patches) { switch(p.type) { case Patch::TEXT: EM_ASM_({ let el = document.getElementById(UTF8ToString($0)); if(el) el.textContent = UTF8ToString($1); }, p.dom_id.c_str(), p.value.c_str()); break; case Patch::ATTR: EM_ASM_({ let el = document.getElementById(UTF8ToString($0)); if(el) el.setAttribute(UTF8ToString($1), UTF8ToString($2)); }, p.dom_id.c_str(), p.key.c_str(), p.value.c_str()); break; case Patch::ADD_CHILD: { std::string html = renderToHTML(const_cast<VNode&>(p.newNode)); EM_ASM_({ let frag = document.createRange().createContextualFragment(UTF8ToString($0)); let parent = document.getElementById(UTF8ToString($1)); if(parent) parent.appendChild(frag); }, html.c_str(), p.dom_id.c_str()); if(p.newNode.onclick) { int cb_id = g_callback_counter++; g_callbacks[cb_id] = p.newNode.onclick; g_domid_to_callback[p.newNode.dom_id] = cb_id; EM_ASM_({ let el = document.getElementById(UTF8ToString($0)); if(el) el.onclick = () => Module.ccall('invokeCallback','void',['number'],[$1]); }, p.newNode.dom_id.c_str(), g_domid_to_callback[p.newNode.dom_id]); } break; } case Patch::REMOVE_CHILD: EM_ASM_({ let el = document.getElementById(UTF8ToString($0)); if(el) el.remove(); }, p.dom_id.c_str()); break; } } } // -------------------- Render or Patch Page -------------------- inline VNode prevPageVNode; // <- now works because of default constructor inline void renderOrPatchPage(VPage& page) { VNode newRoot("div"); // invisible container for body children newRoot.children = page.children; if(prevPageVNode.children.empty()) { // first render std::ostringstream html; for(auto& node : page.children) html << renderToHTML(node); std::ostringstream bodyAttrsOSS; for(auto& [k,v] : page.bodyAttrs) bodyAttrsOSS << k << "=" << v << ";"; std::string bodyAttrsStr = bodyAttrsOSS.str(); EM_ASM_({ const frag = document.createRange().createContextualFragment(UTF8ToString($0)); document.body.appendChild(frag); document.title = UTF8ToString($1); const attrs = UTF8ToString($2).split(";"); for(let i=0;i<attrs.length;i++){ const kv = attrs[i].split("="); if(kv.length===2) document.body.setAttribute(kv[0],kv[1]); } }, html.str().c_str(), page.title.c_str(), bodyAttrsStr.c_str()); wireOnClicks(); prevPageVNode = newRoot; } else { // patch std::vector<Patch> patches; size_t common = std::min(prevPageVNode.children.size(), newRoot.children.size()); for(size_t i=0;i<common;i++) diffNodes(prevPageVNode.children[i], newRoot.children[i], patches); for(size_t i=common;i<newRoot.children.size();i++) patches.push_back(Patch(Patch::ADD_CHILD, "body", "", "", newRoot.children[i])); for(size_t i=common;i<prevPageVNode.children.size();i++) patches.push_back(Patch(Patch::REMOVE_CHILD, prevPageVNode.children[i].dom_id)); applyPatches(patches); prevPageVNode = newRoot; } }